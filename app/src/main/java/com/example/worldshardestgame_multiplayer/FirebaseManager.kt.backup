package com.example.worldshardestgame_multiplayer

import com.google.firebase.database.*
import android.util.Log

class FirebaseManager {
    private val database = FirebaseDatabase.getInstance("https://world-s-hardest-game-default-rtdb.europe-west1.firebasedatabase.app/")
    val gamesRef = database.getReference("games")
    val invitationsRef = database.getReference("invitations")

    companion object {
        private const val TAG = "FirebaseManager"
        private var persistenceEnabled = false
    }

    init {
        // Aktiviere Firebase Offline Persistence (nur einmal)
        if (!persistenceEnabled) {
            try {
                database.setPersistenceEnabled(true)
                persistenceEnabled = true
                Log.d(TAG, "Firebase Persistence aktiviert")
            } catch (e: Exception) {
                Log.w(TAG, "Persistence bereits aktiviert oder Fehler: ${e.message}")
            }
        }

        // Überwache die Verbindung zu Firebase
        setupConnectionMonitoring()
    }

    /**
     * Überwacht die Verbindung zu Firebase und logged den Status
     */
    private fun setupConnectionMonitoring() {
        val connectedRef = database.getReference(".info/connected")
        connectedRef.addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val connected = snapshot.getValue(Boolean::class.java) ?: false
                if (connected) {
                    Log.d(TAG, "✅ Mit Firebase verbunden")
                } else {
                    Log.w(TAG, "❌ Von Firebase getrennt - onDisconnect() Callbacks werden ausgeführt")
                }
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(TAG, "Fehler beim Überwachen der Verbindung", error.toException())
            }
        })
    }

    // Spiel erstellen
    fun createGame(hostName: String, lobbyName: String, onGameCreated: (String) -> Unit, onError: (String) -> Unit) {
        val gameId = gamesRef.push().key
        if (gameId == null) {
            onError("Fehler beim Erstellen der Game-ID")
            return
        }

        val gameData = hashMapOf(
            "gameId" to gameId,
            "lobbyName" to lobbyName,
            "hostId" to "player_1",
            "status" to "waiting", // waiting, playing, finished
            "currentLevel" to 1,
            "currentPlayerIndex" to 0,
            "levelStartTime" to ServerValue.TIMESTAMP,
            "timeLimit" to 180000L,
            "players" to hashMapOf(
                "player_1" to hashMapOf(
                    "playerId" to "player_1",
                    "name" to hostName,
                    "levelsCompleted" to 0,
                    "deaths" to 0,
                    "totalTime" to 0L,
                    "isReady" to false,
                    "online" to false,
                    "x" to 0f,
                    "y" to 0f,
                    "lastSeen" to ServerValue.TIMESTAMP
                )
            )
        )

        gamesRef.child(gameId).setValue(gameData)
            .addOnSuccessListener {
                Log.d(TAG, "Game created: $gameId")
                // Setze onDisconnect für automatisches Cleanup
                setupPlayerPresence(gameId, "player_1")
                onGameCreated(gameId)
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "Error creating game", e)
                onError("Fehler beim Erstellen des Spiels: ${e.message}")
            }
    }

    // Spiel beitreten
    fun joinGame(gameId: String, playerName: String, onSuccess: (String) -> Unit, onError: (String) -> Unit) {
        gamesRef.child(gameId).get().addOnSuccessListener { snapshot ->
            if (!snapshot.exists()) {
                onError("Spiel nicht gefunden")
                return@addOnSuccessListener
            }

            val players = snapshot.child("players").children.count()
            val playerId = "player_${players + 1}"

            val playerData = hashMapOf(
                "playerId" to playerId,
                "name" to playerName,
                "levelsCompleted" to 0,
                "deaths" to 0,
                "totalTime" to 0L,
                "isReady" to false,
                "online" to false,
                "x" to 0f,
                "y" to 0f,
                "lastSeen" to ServerValue.TIMESTAMP
            )

            gamesRef.child(gameId).child("players").child(playerId).setValue(playerData)
                .addOnSuccessListener {
                    Log.d(TAG, "Joined game: $gameId as $playerId")
                    // Setze onDisconnect für automatisches Cleanup
                    setupPlayerPresence(gameId, playerId)
                    onSuccess(playerId)
                }
                .addOnFailureListener { e ->
                    Log.e(TAG, "Error joining game", e)
                    onError("Fehler beim Beitreten: ${e.message}")
                }
        }.addOnFailureListener { e ->
            onError("Fehler beim Laden des Spiels: ${e.message}")
        }
    }

    // Spieler-Position aktualisieren
    fun updatePlayerPosition(gameId: String, playerId: String, x: Float, y: Float) {
        gamesRef.child(gameId).child("players").child(playerId).updateChildren(
            mapOf("x" to x, "y" to y)
        )
    }

    // Spieler-Fortschritt aktualisieren
    fun updatePlayerProgress(gameId: String, playerId: String, levelsCompleted: Int, deaths: Int, totalTime: Long) {
        gamesRef.child(gameId).child("players").child(playerId).updateChildren(
            mapOf(
                "levelsCompleted" to levelsCompleted,
                "deaths" to deaths,
                "totalTime" to totalTime
            )
        )
    }

    // Spieler bereit markieren
    fun setPlayerReady(gameId: String, playerId: String, isReady: Boolean) {
        gamesRef.child(gameId).child("players").child(playerId).child("isReady").setValue(isReady)
    }

    // Spiel starten
    fun startGame(gameId: String) {
        gamesRef.child(gameId).updateChildren(
            mapOf(
                "status" to "playing",
                "levelStartTime" to ServerValue.TIMESTAMP
            )
        )
    }

    // Game State aktualisieren
    fun updateGameState(gameId: String, currentLevel: Int, currentPlayerIndex: Int, timeLimit: Long) {
        gamesRef.child(gameId).updateChildren(
            mapOf(
                "currentLevel" to currentLevel,
                "currentPlayerIndex" to currentPlayerIndex,
                "timeLimit" to timeLimit,
                "levelStartTime" to ServerValue.TIMESTAMP
            )
        )
    }

    // Auf Game State Änderungen hören
    fun listenToGameState(gameId: String, onUpdate: (GameStateData) -> Unit) {
        gamesRef.child(gameId).addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                try {
                    val gameStateData = parseGameState(snapshot)
                    onUpdate(gameStateData)
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing game state", e)
                }
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(TAG, "Game state listener cancelled", error.toException())
            }
        })
    }

    // Auf Spieler-Positionen hören
    fun listenToPlayerPositions(gameId: String, onUpdate: (Map<String, PlayerPosition>) -> Unit) {
        gamesRef.child(gameId).child("players").addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val positions = mutableMapOf<String, PlayerPosition>()
                snapshot.children.forEach { playerSnapshot ->
                    val playerId = playerSnapshot.child("playerId").getValue(String::class.java) ?: return@forEach
                    val x = playerSnapshot.child("x").getValue(Float::class.java) ?: 0f
                    val y = playerSnapshot.child("y").getValue(Float::class.java) ?: 0f
                    val name = playerSnapshot.child("name").getValue(String::class.java) ?: ""
                    positions[playerId] = PlayerPosition(playerId, name, x, y)
                }
                onUpdate(positions)
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(TAG, "Player positions listener cancelled", error.toException())
            }
        })
    }

    // Game State parsen
    private fun parseGameState(snapshot: DataSnapshot): GameStateData {
        val players = mutableListOf<PlayerData>()
        snapshot.child("players").children.forEach { playerSnapshot ->
            val player = PlayerData(
                playerId = playerSnapshot.child("playerId").getValue(String::class.java) ?: "",
                name = playerSnapshot.child("name").getValue(String::class.java) ?: "",
                levelsCompleted = playerSnapshot.child("levelsCompleted").getValue(Int::class.java) ?: 0,
                deaths = playerSnapshot.child("deaths").getValue(Int::class.java) ?: 0,
                totalTime = playerSnapshot.child("totalTime").getValue(Long::class.java) ?: 0L,
                isReady = playerSnapshot.child("isReady").getValue(Boolean::class.java) ?: false
            )
            players.add(player)
        }

        return GameStateData(
            gameId = snapshot.child("gameId").getValue(String::class.java) ?: "",
            hostId = snapshot.child("hostId").getValue(String::class.java) ?: "",
            status = snapshot.child("status").getValue(String::class.java) ?: "waiting",
            currentLevel = snapshot.child("currentLevel").getValue(Int::class.java) ?: 1,
            currentPlayerIndex = snapshot.child("currentPlayerIndex").getValue(Int::class.java) ?: 0,
            timeLimit = snapshot.child("timeLimit").getValue(Long::class.java) ?: 180000L,
            players = players
        )
    }


    // Verfügbare Spiele (Lobbys) abrufen
    fun getAvailableGames(onGamesLoaded: (List<GameLobbyInfo>) -> Unit) {
        gamesRef.orderByChild("status").equalTo("waiting").addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val games = mutableListOf<GameLobbyInfo>()
                snapshot.children.forEach { gameSnapshot ->
                    val gameId = gameSnapshot.child("gameId").getValue(String::class.java) ?: return@forEach
                    val lobbyName = gameSnapshot.child("lobbyName").getValue(String::class.java) ?: "Unbekannte Lobby"
                    val playerCount = gameSnapshot.child("players").childrenCount.toInt()
                    val hostName = gameSnapshot.child("players").child("player_1").child("name").getValue(String::class.java) ?: "Unbekannt"

                    // Nur Spiele mit weniger als 4 Spielern anzeigen
                    if (playerCount < 4) {
                        games.add(GameLobbyInfo(gameId, lobbyName, hostName, playerCount, 4))
                    }
                }
                onGamesLoaded(games)
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(TAG, "Error loading games", error.toException())
                onGamesLoaded(emptyList())
            }
        })
    }

    // Spiel beitreten über Lobby-Namen
    fun joinGameByLobbyName(lobbyName: String, playerName: String, onSuccess: (String, String) -> Unit, onError: (String) -> Unit) {
        gamesRef.orderByChild("lobbyName").equalTo(lobbyName).addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                if (!snapshot.exists() || snapshot.childrenCount == 0L) {
                    onError("Lobby '$lobbyName' nicht gefunden")
                    return
                }

                // Suche die ERSTE WARTENDE Lobby mit diesem Namen (ignoriere playing/finished)
                val gameSnapshot = snapshot.children.firstOrNull { gameSnapshot ->
                    val status = gameSnapshot.child("status").getValue(String::class.java)
                    val playerCount = gameSnapshot.child("players").childrenCount.toInt()
                    // Nur wartende Lobbys mit weniger als 4 Spielern
                    status == "waiting" && playerCount < 4
                }

                if (gameSnapshot == null) {
                    // Prüfe ob es Lobbys mit diesem Namen gibt, die aber nicht wartend sind
                    val hasNonWaitingLobby = snapshot.children.any {
                        it.child("status").getValue(String::class.java) != "waiting"
                    }

                    if (hasNonWaitingLobby) {
                        onError("Lobby '$lobbyName' existiert, wartet aber nicht mehr auf Spieler")
                    } else {
                        onError("Lobby '$lobbyName' ist voll oder nicht gefunden")
                    }
                    return
                }

                // Lobby gefunden und ist wartend
                val gameId = gameSnapshot.child("gameId").getValue(String::class.java) ?: ""
                joinGame(gameId, playerName, onSuccess = { playerId ->
                    onSuccess(gameId, playerId)
                }, onError = onError)
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(TAG, "Error finding lobby", error.toException())
                onError("Fehler beim Suchen der Lobby: ${error.message}")
            }
        })
    }

    // Prüfen ob Lobby-Name bereits AKTUELL existiert (nur wartende Lobbys)
    fun checkLobbyNameExists(lobbyName: String, onResult: (Boolean) -> Unit, onError: ((String) -> Unit)? = null) {
        // Query: Suche nach Lobbys mit diesem Namen UND Status "waiting"
        gamesRef.orderByChild("lobbyName").equalTo(lobbyName).addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                if (!snapshot.exists()) {
                    // Keine Lobby mit diesem Namen gefunden
                    onResult(false)
                    return
                }

                // Prüfe ob es eine WARTENDE Lobby mit diesem Namen gibt
                // (Playing/Finished Lobbys blockieren den Namen nicht mehr)
                val existsWaiting = snapshot.children.any { gameSnapshot ->
                    val status = gameSnapshot.child("status").getValue(String::class.java)
                    val playerCount = gameSnapshot.child("players").childrenCount.toInt()

                    // Nur "waiting" Lobbys mit Spielern zählen
                    status == "waiting" && playerCount > 0
                }

                Log.d(TAG, "Lobby '$lobbyName' existiert bereits wartend: $existsWaiting")
                onResult(existsWaiting)
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(TAG, "Error checking lobby name", error.toException())

                // Spezielle Behandlung für Permission denied
                if (error.code == DatabaseError.PERMISSION_DENIED) {
                    onError?.invoke("Firebase-Berechtigung fehlt! Bitte aktiviere Lese-/Schreibrechte in der Firebase Console.")
                } else {
                    onError?.invoke("Fehler beim Prüfen der Lobby: ${error.message}")
                }

                // Fallback: Lobby existiert nicht annehmen (im Zweifel erlauben)
                onResult(false)
            }
        })
    }

    /**
     * Entfernt einen Spieler aus dem Spiel und löscht das Spiel, wenn es leer ist
     */
    fun leaveGame(gameId: String, playerId: String, callback: (Boolean) -> Unit) {
        val gameRef = database.getReference("games/$gameId")

        // Erst den Spieler entfernen
        gameRef.child("players").child(playerId).removeValue()
        gameRef.child("positions").child(playerId).removeValue()

        // Dann prüfen, ob noch Spieler übrig sind
        gameRef.child("players").addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                if (!snapshot.exists() || snapshot.childrenCount == 0L) {
                    // Keine Spieler mehr übrig - lösche das gesamte Spiel UND alle Einladungen
                    gameRef.removeValue().addOnCompleteListener { task ->
                        if (task.isSuccessful) {
                            // Lösche auch alle Einladungen für diese Lobby
                            deleteInvitationsForGame(gameId)
                            Log.d(TAG, "Spiel $gameId wurde gelöscht (keine Spieler mehr)")
                        }
                        callback(task.isSuccessful)
                    }
                } else {
                    // Es gibt noch Spieler - prüfe ob der Host gegangen ist
                    gameRef.child("hostId").get().addOnSuccessListener { hostSnapshot ->
                        val currentHostId = hostSnapshot.getValue(String::class.java)
                        if (currentHostId == playerId) {
                            // Host ist gegangen - übertrage Host-Rechte an ersten verfügbaren Spieler
                            val newHostId = snapshot.children.firstOrNull()?.key
                            if (newHostId != null) {
                                gameRef.child("hostId").setValue(newHostId)
                                Log.d(TAG, "Neuer Host: $newHostId")
                            }
                        }
                        callback(true)
                    }
                }
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(TAG, "Fehler beim Verlassen: ${error.message}")
                callback(false)
            }
        })
    }

    /**
     * Löscht ein Spiel komplett aus der Datenbank
     */
    fun deleteGame(gameId: String, callback: (Boolean) -> Unit) {
        database.getReference("games/$gameId").removeValue().addOnCompleteListener { task ->
            if (task.isSuccessful) {
                Log.d(TAG, "Spiel $gameId wurde erfolgreich gelöscht")
            } else {
                Log.e(TAG, "Fehler beim Löschen von Spiel $gameId")
            }
            callback(task.isSuccessful)
        }
    }

    /**
     * Prüft ob ein Spiel noch existiert
     */
    fun gameExists(gameId: String, callback: (Boolean) -> Unit) {
        database.getReference("games/$gameId").get().addOnSuccessListener { snapshot ->
            callback(snapshot.exists())
        }.addOnFailureListener {
            callback(false)
        }
    }

    /**
     * Entfernt alle Listener für ein bestimmtes Spiel
     */
    fun removeGameListeners(gameId: String) {
        val gameRef = database.getReference("games/$gameId")
        gameRef.removeEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {}
            override fun onCancelled(error: DatabaseError) {}
        })
    }


    /**
     * Löscht nur leere oder veraltete Lobbys (ohne aktive Spieler)
     * Prüft auch ob alle Spieler offline sind
     */
    fun cleanupEmptyGames(callback: (Boolean, Int) -> Unit) {
        gamesRef.get().addOnSuccessListener { snapshot ->
            var deletedCount = 0
            var processedCount = 0
            val totalGames = snapshot.childrenCount.toInt()

            if (totalGames == 0) {
                callback(true, 0)
                return@addOnSuccessListener
            }

            snapshot.children.forEach { gameSnapshot ->
                val gameId = gameSnapshot.child("gameId").getValue(String::class.java) ?: run {
                    processedCount++
                    if (processedCount == totalGames) callback(true, deletedCount)
                    return@forEach
                }

                val playerCount = gameSnapshot.child("players").childrenCount.toInt()

                // Lösche Spiele ohne Spieler sofort
                if (playerCount == 0) {
                    gamesRef.child(gameId).removeValue().addOnSuccessListener {
                        deleteInvitationsForGame(gameId)
                        deletedCount++
                        processedCount++
                        Log.d(TAG, "Leeres Spiel gelöscht: $gameId")
                        if (processedCount == totalGames) callback(true, deletedCount)
                    }.addOnFailureListener {
                        processedCount++
                        if (processedCount == totalGames) callback(true, deletedCount)
                    }
                    return@forEach
                }

                // Prüfe ob alle Spieler offline sind
                var allOffline = true
                val playersSnapshot = gameSnapshot.child("players")
                for (playerSnapshot in playersSnapshot.children) {
                    val online = playerSnapshot.child("online").getValue(Boolean::class.java) ?: false
                    if (online) {
                        allOffline = false
                        break
                    }
                }

                if (allOffline) {
                    // Alle Spieler sind offline - lösche die Lobby
                    gamesRef.child(gameId).removeValue().addOnSuccessListener {
                        deleteInvitationsForGame(gameId)
                        deletedCount++
                        processedCount++
                        Log.d(TAG, "Lobby mit nur offline Spielern gelöscht: $gameId")
                        if (processedCount == totalGames) callback(true, deletedCount)
                    }.addOnFailureListener {
                        processedCount++
                        if (processedCount == totalGames) callback(true, deletedCount)
                    }
                } else {
                    processedCount++
                    if (processedCount == totalGames) callback(true, deletedCount)
                }
            }
        }.addOnFailureListener {
            Log.e(TAG, "Fehler beim Cleanup")
            callback(false, 0)
        }
    }

    // Spiel erstellen mit Authentication
    fun createGameWithAuth(
        hostUserId: String,
        hostName: String,
        lobbyName: String,
        isPublic: Boolean,
        invitedUserIds: List<String>,
        onGameCreated: (gameId: String, playerId: String) -> Unit,
        onError: (String) -> Unit
    ) {
        val gameId = gamesRef.push().key
        if (gameId == null) {
            onError("Fehler beim Erstellen der Game-ID")
            return
        }

        val gameData = hashMapOf(
            "gameId" to gameId,
            "lobbyName" to lobbyName,
            "hostId" to "player_1",
            "hostUserId" to hostUserId,
            "isPublic" to isPublic,
            "maxPlayers" to 4,
            "status" to "waiting",
            "currentLevel" to 1,
            "currentPlayerIndex" to 0,
            "levelStartTime" to ServerValue.TIMESTAMP,
            "timeLimit" to 180000L,
            "createdAt" to ServerValue.TIMESTAMP,
            "invitedUsers" to invitedUserIds,
            "players" to hashMapOf(
                "player_1" to hashMapOf(
                    "playerId" to "player_1",
                    "userId" to hostUserId,
                    "name" to hostName,
                    "levelsCompleted" to 0,
                    "deaths" to 0,
                    "totalTime" to 0L,
                    "isReady" to false,
                    "online" to false,
                    "x" to 0f,
                    "y" to 0f,
                    "lastSeen" to ServerValue.TIMESTAMP
                )
            )
        )

        gamesRef.child(gameId).setValue(gameData)
            .addOnSuccessListener {
                Log.d(TAG, "Game created: $gameId (public=$isPublic)")
                // Setze Presence-Detection für den Host
                setupPlayerPresence(gameId, "player_1")
                onGameCreated(gameId, "player_1")
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "Error creating game", e)
                onError("Fehler beim Erstellen des Spiels: ${e.message}")
            }
    }

    // Spiel beitreten mit Authentication
    fun joinGameWithAuth(
        gameId: String,
        userId: String,
        playerName: String,
        onSuccess: (playerId: String) -> Unit,
        onError: (String) -> Unit
    ) {
        gamesRef.child(gameId).get().addOnSuccessListener { snapshot ->
            if (!snapshot.exists()) {
                onError("Spiel nicht gefunden")
                return@addOnSuccessListener
            }

            // Check if game is full
            val maxPlayers = snapshot.child("maxPlayers").getValue(Int::class.java) ?: 4
            val players = snapshot.child("players").children.count()

            if (players >= maxPlayers) {
                onError("Lobby ist voll")
                return@addOnSuccessListener
            }

            // Check if private and user is invited
            val isPublic = snapshot.child("isPublic").getValue(Boolean::class.java) ?: true
            val hostUserId = snapshot.child("hostUserId").getValue(String::class.java)

            if (!isPublic && userId != hostUserId) {
                val invitedUsers = mutableListOf<String>()
                snapshot.child("invitedUsers").children.forEach {
                    it.getValue(String::class.java)?.let { invitedUserId -> invitedUsers.add(invitedUserId) }
                }

                if (!invitedUsers.contains(userId)) {
                    onError("Du bist nicht zu dieser privaten Lobby eingeladen")
                    return@addOnSuccessListener
                }
            }

            val playerId = "player_${players + 1}"

            val playerData = hashMapOf(
                "playerId" to playerId,
                "userId" to userId,
                "name" to playerName,
                "levelsCompleted" to 0,
                "deaths" to 0,
                "totalTime" to 0L,
                "isReady" to false,
                "online" to false,
                "x" to 0f,
                "y" to 0f,
                "lastSeen" to ServerValue.TIMESTAMP
            )

            gamesRef.child(gameId).child("players").child(playerId).setValue(playerData)
                .addOnSuccessListener {
                    Log.d(TAG, "Joined game: $gameId as $playerId")
                    // Setze Presence-Detection für den beitretenden Spieler
                    setupPlayerPresence(gameId, playerId)
                    onSuccess(playerId)
                }
                .addOnFailureListener { e ->
                    Log.e(TAG, "Error joining game", e)
                    onError("Fehler beim Beitreten: ${e.message}")
                }
        }.addOnFailureListener { e ->
            onError("Fehler beim Laden des Spiels: ${e.message}")
        }
    }

    /**
     * Sendet eine Einladung an einen User
     */
    fun sendInvitation(
        gameId: String,
        lobbyName: String,
        fromUserId: String,
        fromUsername: String,
        toUserId: String,
        toUsername: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        val invitationId = invitationsRef.push().key
        if (invitationId == null) {
            onError("Fehler beim Erstellen der Einladungs-ID")
            return
        }

        val invitation = hashMapOf(
            "invitationId" to invitationId,
            "gameId" to gameId,
            "lobbyName" to lobbyName,
            "fromUserId" to fromUserId,
            "fromUsername" to fromUsername,
            "toUserId" to toUserId,
            "toUsername" to toUsername,
            "status" to "pending",
            "timestamp" to ServerValue.TIMESTAMP
        )

        invitationsRef.child(toUserId).child(invitationId).setValue(invitation)
            .addOnSuccessListener {
                Log.d(TAG, "Invitation sent: $fromUsername -> $toUsername for game $gameId")
                onSuccess()
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "Error sending invitation", e)
                onError("Fehler beim Senden der Einladung: ${e.message}")
            }
    }

    /**
     * Hört auf neue Einladungen für einen User
     */
    fun listenToInvitations(
        userId: String,
        onInvitation: (com.example.worldshardestgame_multiplayer.models.Invitation) -> Unit
    ) {
        invitationsRef.child(userId).orderByChild("status").equalTo("pending")
            .addChildEventListener(object : ChildEventListener {
                override fun onChildAdded(snapshot: DataSnapshot, previousChildName: String?) {
                    try {
                        val invitationId = snapshot.child("invitationId").getValue(String::class.java) ?: return
                        val gameId = snapshot.child("gameId").getValue(String::class.java) ?: return
                        val lobbyName = snapshot.child("lobbyName").getValue(String::class.java) ?: return
                        val fromUserId = snapshot.child("fromUserId").getValue(String::class.java) ?: return
                        val fromUsername = snapshot.child("fromUsername").getValue(String::class.java) ?: return
                        val toUserId = snapshot.child("toUserId").getValue(String::class.java) ?: return
                        val toUsername = snapshot.child("toUsername").getValue(String::class.java) ?: return
                        val status = snapshot.child("status").getValue(String::class.java) ?: "pending"
                        val timestamp = snapshot.child("timestamp").getValue(Long::class.java) ?: 0

                        val invitation = com.example.worldshardestgame_multiplayer.models.Invitation(
                            invitationId = invitationId,
                            gameId = gameId,
                            lobbyName = lobbyName,
                            fromUserId = fromUserId,
                            fromUsername = fromUsername,
                            toUserId = toUserId,
                            toUsername = toUsername,
                            status = status,
                            timestamp = timestamp
                        )

                        onInvitation(invitation)
                    } catch (e: Exception) {
                        Log.e(TAG, "Error parsing invitation", e)
                    }
                }

                override fun onChildChanged(snapshot: DataSnapshot, previousChildName: String?) {}
                override fun onChildRemoved(snapshot: DataSnapshot) {}
                override fun onChildMoved(snapshot: DataSnapshot, previousChildName: String?) {}
                override fun onCancelled(error: DatabaseError) {
                    Log.e(TAG, "Invitation listener cancelled", error.toException())
                }
            })
    }

    /**
     * Akzeptiert eine Einladung
     */
    fun acceptInvitation(
        invitation: com.example.worldshardestgame_multiplayer.models.Invitation,
        userId: String,
        username: String,
        onSuccess: (playerId: String) -> Unit,
        onError: (String) -> Unit
    ) {
        // Erst prüfen ob die Lobby noch existiert
        gamesRef.child(invitation.gameId).get().addOnSuccessListener { snapshot ->
            if (!snapshot.exists()) {
                // Lobby existiert nicht mehr
                updateInvitationStatus(invitation.invitationId, invitation.toUserId, "declined")
                onError("Diese Lobby existiert nicht mehr")
                return@addOnSuccessListener
            }

            val status = snapshot.child("status").getValue(String::class.java)
            if (status != "waiting") {
                updateInvitationStatus(invitation.invitationId, invitation.toUserId, "declined")
                onError("Diese Lobby wartet nicht mehr auf Spieler")
                return@addOnSuccessListener
            }

            // Lobby beitreten
            joinGameWithAuth(
                gameId = invitation.gameId,
                userId = userId,
                playerName = username,
                onSuccess = { playerId ->
                    // Einladung als akzeptiert markieren
                    updateInvitationStatus(invitation.invitationId, invitation.toUserId, "accepted")
                    onSuccess(playerId)
                },
                onError = { error ->
                    updateInvitationStatus(invitation.invitationId, invitation.toUserId, "declined")
                    onError(error)
                }
            )
        }.addOnFailureListener { e ->
            onError("Fehler beim Laden der Lobby: ${e.message}")
        }
    }

    /**
     * Lehnt eine Einladung ab
     */
    fun declineInvitation(
        invitationId: String,
        userId: String,
        onSuccess: () -> Unit
    ) {
        updateInvitationStatus(invitationId, userId, "declined")
        onSuccess()
    }

    /**
     * Aktualisiert den Status einer Einladung
     */
    private fun updateInvitationStatus(invitationId: String, userId: String, status: String) {
        invitationsRef.child(userId).child(invitationId).child("status").setValue(status)
        Log.d(TAG, "Invitation $invitationId updated to: $status")
    }

    /**
     * Löscht alle Einladungen für eine Lobby (wenn Lobby gelöscht wird)
     */
    fun deleteInvitationsForGame(gameId: String) {
        invitationsRef.get().addOnSuccessListener { snapshot ->
            snapshot.children.forEach { userSnapshot ->
                userSnapshot.children.forEach { invitationSnapshot ->
                    val invGameId = invitationSnapshot.child("gameId").getValue(String::class.java)
                    if (invGameId == gameId) {
                        invitationSnapshot.ref.removeValue()
                    }
                }
            }
            Log.d(TAG, "Deleted all invitations for game: $gameId")
        }
    }

    /**
     * Prüft ob eine Lobby noch aktiv ist (für Cleanup)
     */
    fun isLobbyActive(gameId: String, callback: (Boolean) -> Unit) {
        gamesRef.child(gameId).get().addOnSuccessListener { snapshot ->
            if (!snapshot.exists()) {
                callback(false)
                return@addOnSuccessListener
            }

            val status = snapshot.child("status").getValue(String::class.java)
            val playerCount = snapshot.child("players").childrenCount.toInt()

            // Lobby ist aktiv wenn sie existiert, status="waiting" und mindestens 1 Spieler hat
            val isActive = status == "waiting" && playerCount > 0
            callback(isActive)
        }.addOnFailureListener {
            callback(false)
        }
    }

    // Set zum Tracken welche GameIDs bereits einen Cleanup-Listener haben
    private val gameCleanupListeners = mutableSetOf<String>()

    /**
     * Setzt die Presence-Detection für einen Spieler auf.
     * Wenn der Spieler die Verbindung verliert, wird er automatisch entfernt.
     */
    fun setupPlayerPresence(gameId: String, playerId: String) {
        val playerRef = gamesRef.child(gameId).child("players").child(playerId)
        val gameRef = gamesRef.child(gameId)

        // Setze Spieler als online
        playerRef.child("online").setValue(true)
        playerRef.child("lastSeen").setValue(ServerValue.TIMESTAMP)

        // WICHTIG: Bei Disconnect entferne den Spieler komplett aus der Lobby
        // Das verhindert, dass leere Lobbys zurückbleiben
        playerRef.onDisconnect().removeValue().addOnSuccessListener {
            Log.d(TAG, "onDisconnect für $playerId in $gameId registriert")
        }.addOnFailureListener { e ->
            Log.e(TAG, "Fehler beim Registrieren von onDisconnect für $playerId", e)
        }

        // Lösche auch die Position bei Disconnect
        gamesRef.child(gameId).child("positions").child(playerId)
            .onDisconnect().removeValue()

        // WICHTIG: Setze einen dauerhaften Cleanup-Listener für diese Lobby
        // Dieser überwacht die Spielerliste und löscht die Lobby wenn sie leer wird
        setupGameCleanupListener(gameId)
    }



    /**
     * Registriert einen dauerhaften Listener der das Spiel löscht wenn keine Spieler mehr vorhanden sind.
     * Wird nur einmal pro Spiel aufgerufen.
     *
     * Da onDisconnect() die Spieler automatisch entfernt, überwachen wir nur ob die Spielerliste leer wird.
     */
    private fun setupGameCleanupListener(gameId: String) {
        // Wenn bereits ein Listener für dieses Spiel existiert, nichts tun
        if (gameCleanupListeners.contains(gameId)) {
            return
        }

        gameCleanupListeners.add(gameId)
        val gameRef = gamesRef.child(gameId)

        // Überwache die Spielerliste - wenn sie leer wird, lösche die Lobby
        gameRef.child("players").addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                if (!snapshot.exists() || snapshot.childrenCount == 0L) {
                    // Keine Spieler mehr vorhanden - lösche das Spiel sofort
                    Log.d(TAG, "Keine Spieler mehr in $gameId - lösche Spiel")
                    gameRef.removeValue().addOnSuccessListener {
                        deleteInvitationsForGame(gameId)
                        gameCleanupListeners.remove(gameId)
                        Log.d(TAG, "Spiel $gameId automatisch gelöscht (keine Spieler)")
                    }
                }
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(TAG, "Fehler beim Überwachen der Spieler-Präsenz", error.toException())
                gameCleanupListeners.remove(gameId)
            }
        })
    }

    /**
     * Aktualisiert den lastSeen Timestamp eines Spielers
     */
    fun updatePlayerPresence(gameId: String, playerId: String) {
        gamesRef.child(gameId).child("players").child(playerId)
            .child("lastSeen").setValue(ServerValue.TIMESTAMP)
    }

    /**
     * Entfernt inaktive Spieler aus einer Lobby (lastSeen > 30 Sekunden)
     */
    fun cleanupInactivePlayers(gameId: String) {
        val gameRef = gamesRef.child(gameId)
        val currentTime = System.currentTimeMillis()
        val timeout = 30000L // 30 Sekunden

        gameRef.child("players").get().addOnSuccessListener { snapshot ->
            val inactivePlayers = mutableListOf<String>()

            for (playerSnapshot in snapshot.children) {
                val lastSeen = playerSnapshot.child("lastSeen").getValue(Long::class.java) ?: 0L
                if (currentTime - lastSeen > timeout) {
                    playerSnapshot.key?.let { inactivePlayers.add(it) }
                }
            }

            // Entferne inaktive Spieler
            inactivePlayers.forEach { playerId ->
                Log.d(TAG, "Entferne inaktiven Spieler: $playerId")
                leaveGame(gameId, playerId) { }
            }
        }
    }

    /**
     * Räumt alte oder leere Lobbys auf
     * - Löscht Lobbys, die älter als 1 Stunde sind und alle Spieler offline sind
     * - Löscht Lobbys ohne Spieler
     */
    fun cleanupOldLobbies() {
        gamesRef.get().addOnSuccessListener { snapshot ->
            val currentTime = System.currentTimeMillis()
            val maxAge = 3600000L // 1 Stunde

            for (gameSnapshot in snapshot.children) {
                val gameId = gameSnapshot.key ?: continue

                // Prüfe ob Lobby Spieler hat
                val playersSnapshot = gameSnapshot.child("players")
                if (!playersSnapshot.exists() || playersSnapshot.childrenCount == 0L) {
                    // Keine Spieler - lösche Lobby
                    Log.d(TAG, "Lösche leere Lobby: $gameId")
                    gamesRef.child(gameId).removeValue().addOnSuccessListener {
                        deleteInvitationsForGame(gameId)
                    }
                    continue
                }

                // Prüfe ob alle Spieler offline sind
                var anyOnline = false
                for (playerSnapshot in playersSnapshot.children) {
                    val online = playerSnapshot.child("online").getValue(Boolean::class.java) ?: false
                    if (online) {
                        anyOnline = true
                        break
                    }
                }

                if (!anyOnline) {
                    // Alle offline - prüfe Alter der Lobby
                    val createdAt = gameSnapshot.child("createdAt").getValue(Long::class.java) ?: 0L
                    if (createdAt > 0 && currentTime - createdAt > maxAge) {
                        Log.d(TAG, "Lösche alte Lobby mit offline Spielern: $gameId")
                        gamesRef.child(gameId).removeValue().addOnSuccessListener {
                            deleteInvitationsForGame(gameId)
                        }
                    } else {
                        // Lobby ist nicht alt genug - lösche nach 10 Sekunden wenn immer noch alle offline
                        android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                            gamesRef.child(gameId).child("players").get().addOnSuccessListener { checkSnapshot ->
                                var stillAnyOnline = false
                                for (playerSnapshot in checkSnapshot.children) {
                                    val online = playerSnapshot.child("online").getValue(Boolean::class.java) ?: false
                                    if (online) {
                                        stillAnyOnline = true
                                        break
                                    }
                                }

                                if (!stillAnyOnline && (!checkSnapshot.exists() || checkSnapshot.childrenCount == 0L)) {
                                    Log.d(TAG, "Lösche Lobby mit dauerhaft offline Spielern: $gameId")
                                    gamesRef.child(gameId).removeValue().addOnSuccessListener {
                                        deleteInvitationsForGame(gameId)
                                    }
                                } else if (!stillAnyOnline) {
                                    Log.d(TAG, "Lösche Lobby - alle Spieler offline: $gameId")
                                    gamesRef.child(gameId).removeValue().addOnSuccessListener {
                                        deleteInvitationsForGame(gameId)
                                    }
                                }
                            }
                        }, 10000) // 10 Sekunden Wartezeit
                    }
                }
            }
        }.addOnFailureListener { e ->
            Log.e(TAG, "Fehler beim Cleanup alter Lobbys", e)
        }
    }
}

// Data Classes
data class GameStateData(
    val gameId: String,
    val hostId: String,
    val status: String,
    val currentLevel: Int,
    val currentPlayerIndex: Int,
    val timeLimit: Long,
    val players: List<PlayerData>
)

data class PlayerData(
    val playerId: String,
    val name: String,
    val levelsCompleted: Int,
    val deaths: Int,
    val totalTime: Long,
    val isReady: Boolean
)

data class PlayerPosition(
    val playerId: String,
    val name: String,
    val x: Float,
    val y: Float
)

data class GameLobbyInfo(
    val gameId: String,
    val lobbyName: String,
    val hostName: String,
    val currentPlayers: Int,
    val maxPlayers: Int
)

    // ==================== FREUNDESLISTE ====================

    /**
     * Sendet eine Freundschaftsanfrage an einen Benutzer
     */
    fun sendFriendRequest(
        fromUserId: String,
        fromUsername: String,
        toUserId: String,
        toUsername: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        val requestId = database.child("friendRequests").push().key ?: run {
            onError("Konnte keine Request-ID erstellen")
            return
        }

        val friendRequest = hashMapOf(
            "requestId" to requestId,
            "fromUserId" to fromUserId,
            "fromUsername" to fromUsername,
            "toUserId" to toUserId,
            "toUsername" to toUsername,
            "status" to "pending",
            "timestamp" to System.currentTimeMillis()
        )

        database.child("friendRequests").child(requestId).setValue(friendRequest)
            .addOnSuccessListener { onSuccess() }
            .addOnFailureListener { onError(it.message ?: "Fehler beim Senden") }
    }

    /**
     * Holt alle ausstehenden Freundschaftsanfragen für einen Benutzer
     */
    fun getPendingFriendRequests(
        userId: String,
        onResult: (List<com.example.worldshardestgame_multiplayer.models.FriendRequest>) -> Unit
    ) {
        database.child("friendRequests")
            .orderByChild("toUserId")
            .equalTo(userId)
            .addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    val requests = mutableListOf<com.example.worldshardestgame_multiplayer.models.FriendRequest>()
                    for (child in snapshot.children) {
                        val status = child.child("status").getValue(String::class.java) ?: "pending"
                        if (status == "pending") {
                            child.getValue(com.example.worldshardestgame_multiplayer.models.FriendRequest::class.java)?.let {
                                requests.add(it)
                            }
                        }
                    }
                    onResult(requests)
                }

                override fun onCancelled(error: DatabaseError) {
                    onResult(emptyList())
                }
            })
    }

    /**
     * Akzeptiert eine Freundschaftsanfrage
     */
    fun acceptFriendRequest(
        requestId: String,
        fromUserId: String,
        fromUsername: String,
        toUserId: String,
        toUsername: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        // Update Request Status
        database.child("friendRequests").child(requestId).child("status").setValue("accepted")

        // Füge beide Benutzer zur Freundesliste hinzu
        val friend1 = hashMapOf(
            "userId" to fromUserId,
            "username" to fromUsername,
            "status" to "offline",
            "addedAt" to System.currentTimeMillis()
        )

        val friend2 = hashMapOf(
            "userId" to toUserId,
            "username" to toUsername,
            "status" to "offline",
            "addedAt" to System.currentTimeMillis()
        )

        val updates = hashMapOf<String, Any>(
            "friends/$toUserId/$fromUserId" to friend1,
            "friends/$fromUserId/$toUserId" to friend2
        )

        database.updateChildren(updates)
            .addOnSuccessListener { onSuccess() }
            .addOnFailureListener { onError(it.message ?: "Fehler beim Akzeptieren") }
    }

    /**
     * Lehnt eine Freundschaftsanfrage ab
     */
    fun rejectFriendRequest(
        requestId: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        database.child("friendRequests").child(requestId).child("status").setValue("rejected")
            .addOnSuccessListener { onSuccess() }
            .addOnFailureListener { onError(it.message ?: "Fehler beim Ablehnen") }
    }

    /**
     * Holt die Freundesliste eines Benutzers
     */
    fun getFriends(
        userId: String,
        onResult: (List<com.example.worldshardestgame_multiplayer.models.Friend>) -> Unit
    ) {
        database.child("friends").child(userId)
            .addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    val friends = mutableListOf<com.example.worldshardestgame_multiplayer.models.Friend>()
                    for (child in snapshot.children) {
                        child.getValue(com.example.worldshardestgame_multiplayer.models.Friend::class.java)?.let {
                            friends.add(it)
                        }
                    }
                    onResult(friends)
                }

                override fun onCancelled(error: DatabaseError) {
                    onResult(emptyList())
                }
            })
    }

    /**
     * Entfernt einen Freund aus der Freundesliste
     */
    fun removeFriend(
        userId: String,
        friendId: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        val updates = hashMapOf<String, Any?>(
            "friends/$userId/$friendId" to null,
            "friends/$friendId/$userId" to null
        )

        database.updateChildren(updates)
            .addOnSuccessListener { onSuccess() }
            .addOnFailureListener { onError(it.message ?: "Fehler beim Entfernen") }
    }

    /**
     * Sucht nach Benutzern anhand des Usernamens
     */
    fun searchUsers(
        searchQuery: String,
        currentUserId: String,
        onResult: (List<com.example.worldshardestgame_multiplayer.models.User>) -> Unit
    ) {
        database.child("users")
            .orderByChild("username")
            .startAt(searchQuery)
            .endAt(searchQuery + "\uf8ff")
            .addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    val users = mutableListOf<com.example.worldshardestgame_multiplayer.models.User>()
                    for (child in snapshot.children) {
                        child.getValue(com.example.worldshardestgame_multiplayer.models.User::class.java)?.let { user ->
                            if (user.userId != currentUserId) {
                                users.add(user)
                            }
                        }
                    }
                    onResult(users)
                }

                override fun onCancelled(error: DatabaseError) {
                    onResult(emptyList())
                }
            })
    }

    /**
     * Lädt einen Freund in die Lobby ein
     */
    fun inviteFriendToLobby(
        gameId: String,
        lobbyName: String,
        fromUserId: String,
        fromUsername: String,
        toUserId: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        val invitationId = database.child("invitations").push().key ?: run {
            onError("Konnte keine Invitation-ID erstellen")
            return
        }

        val invitation = hashMapOf(
            "invitationId" to invitationId,
            "gameId" to gameId,
            "lobbyName" to lobbyName,
            "fromUserId" to fromUserId,
            "fromUsername" to fromUsername,
            "toUserId" to toUserId,
            "status" to "pending",
            "timestamp" to System.currentTimeMillis()
        )

        database.child("invitations").child(invitationId).setValue(invitation)
            .addOnSuccessListener { onSuccess() }
            .addOnFailureListener { onError(it.message ?: "Fehler beim Einladen") }
    }

    // ==================== KICK FUNKTIONALITÄT ====================

    /**
     * Kickt einen Spieler aus der Lobby (nur vom Host aufrufbar)
     */
    fun kickPlayer(
        gameId: String,
        playerId: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        // Prüfe ob der Spieler existiert
        database.child("games").child(gameId).child("players").child(playerId)
            .addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    if (!snapshot.exists()) {
                        onError("Spieler nicht gefunden")
                        return
                    }

                    // Entferne den Spieler
                    val updates = hashMapOf<String, Any?>(
                        "games/$gameId/players/$playerId" to null,
                        "playerPresence/$gameId/$playerId" to null
                    )

                    database.updateChildren(updates)
                        .addOnSuccessListener {
                            // Setze kicked Flag für den Spieler
                            database.child("games").child(gameId).child("kicked").child(playerId)
                                .setValue(true)
                            onSuccess()
                        }
                        .addOnFailureListener { onError(it.message ?: "Fehler beim Kicken") }
                }

                override fun onCancelled(error: DatabaseError) {
                    onError("Fehler beim Prüfen des Spielers")
                }
            })
    }

    /**
     * Prüft ob ein Spieler gekickt wurde
     */
    fun checkIfKicked(
        gameId: String,
        playerId: String,
        onResult: (Boolean) -> Unit
    ) {
        database.child("games").child(gameId).child("kicked").child(playerId)
            .addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    val isKicked = snapshot.getValue(Boolean::class.java) ?: false
                    onResult(isKicked)
                }

                override fun onCancelled(error: DatabaseError) {
                    onResult(false)
                }
            })
    }

    /**
     * Listener für Kicked-Status
     */
    fun listenForKick(
        gameId: String,
        playerId: String,
        onKicked: () -> Unit
    ) {
        database.child("games").child(gameId).child("kicked").child(playerId)
            .addValueEventListener(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    val isKicked = snapshot.getValue(Boolean::class.java) ?: false
                    if (isKicked) {
                        onKicked()
                    }
                }

                override fun onCancelled(error: DatabaseError) {
                    // Ignore
                }
            })
    }

    // ==================== FREUNDESLISTE ====================

    /**
     * Holt die Freundesliste eines Users
     */
    fun getFriends(userId: String, onResult: (List<com.example.worldshardestgame_multiplayer.models.Friend>) -> Unit) {
        database.child("users").child(userId).child("friends")
            .addValueEventListener(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    val friends = mutableListOf<com.example.worldshardestgame_multiplayer.models.Friend>()
                    for (child in snapshot.children) {
                        val friend = child.getValue(com.example.worldshardestgame_multiplayer.models.Friend::class.java)
                        if (friend != null) {
                            friends.add(friend)
                        }
                    }
                    onResult(friends)
                }

                override fun onCancelled(error: DatabaseError) {
                    Log.e(TAG, "Fehler beim Laden der Freunde", error.toException())
                    onResult(emptyList())
                }
            })
    }

    /**
     * Holt ausstehende Freundschaftsanfragen
     */
    fun getPendingFriendRequests(userId: String, onResult: (List<com.example.worldshardestgame_multiplayer.models.FriendRequest>) -> Unit) {
        database.child("friendRequests")
            .orderByChild("toUserId")
            .equalTo(userId)
            .addValueEventListener(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    val requests = mutableListOf<com.example.worldshardestgame_multiplayer.models.FriendRequest>()
                    for (child in snapshot.children) {
                        val request = child.getValue(com.example.worldshardestgame_multiplayer.models.FriendRequest::class.java)
                        if (request != null && request.status == "pending") {
                            requests.add(request)
                        }
                    }
                    onResult(requests)
                }

                override fun onCancelled(error: DatabaseError) {
                    Log.e(TAG, "Fehler beim Laden der Anfragen", error.toException())
                    onResult(emptyList())
                }
            })
    }

    /**
     * Sucht nach Users anhand des Usernamens
     */
    fun searchUsers(query: String, currentUserId: String, onResult: (List<com.example.worldshardestgame_multiplayer.models.User>) -> Unit) {
        database.child("users")
            .orderByChild("username")
            .startAt(query)
            .endAt(query + "\uf8ff")
            .addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    val users = mutableListOf<com.example.worldshardestgame_multiplayer.models.User>()
                    for (child in snapshot.children) {
                        val user = child.getValue(com.example.worldshardestgame_multiplayer.models.User::class.java)
                        if (user != null && user.userId != currentUserId) {
                            users.add(user)
                        }
                    }
                    onResult(users)
                }

                override fun onCancelled(error: DatabaseError) {
                    Log.e(TAG, "Fehler bei der Suche", error.toException())
                    onResult(emptyList())
                }
            })
    }

    /**
     * Sendet eine Freundschaftsanfrage
     */
    fun sendFriendRequest(
        fromUserId: String,
        fromUsername: String,
        toUserId: String,
        toUsername: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        // Prüfe ob bereits eine Anfrage existiert
        database.child("friendRequests")
            .orderByChild("fromUserId")
            .equalTo(fromUserId)
            .addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    var alreadyExists = false
                    for (child in snapshot.children) {
                        val request = child.getValue(com.example.worldshardestgame_multiplayer.models.FriendRequest::class.java)
                        if (request != null && request.toUserId == toUserId && request.status == "pending") {
                            alreadyExists = true
                            break
                        }
                    }

                    if (alreadyExists) {
                        onError("Anfrage bereits gesendet")
                        return
                    }

                    // Erstelle neue Anfrage
                    val requestId = database.child("friendRequests").push().key
                    if (requestId == null) {
                        onError("Fehler beim Erstellen der Anfrage")
                        return
                    }

                    val request = com.example.worldshardestgame_multiplayer.models.FriendRequest(
                        requestId = requestId,
                        fromUserId = fromUserId,
                        fromUsername = fromUsername,
                        toUserId = toUserId,
                        toUsername = toUsername,
                        status = "pending",
                        timestamp = System.currentTimeMillis()
                    )

                    database.child("friendRequests").child(requestId).setValue(request)
                        .addOnSuccessListener { onSuccess() }
                        .addOnFailureListener { onError(it.message ?: "Unbekannter Fehler") }
                }

                override fun onCancelled(error: DatabaseError) {
                    onError("Fehler beim Prüfen bestehender Anfragen")
                }
            })
    }

    /**
     * Akzeptiert eine Freundschaftsanfrage
     */
    fun acceptFriendRequest(
        requestId: String,
        fromUserId: String,
        fromUsername: String,
        toUserId: String,
        toUsername: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        val updates = hashMapOf<String, Any>(
            // Markiere Anfrage als akzeptiert
            "friendRequests/$requestId/status" to "accepted",

            // Füge beide User als Freunde hinzu
            "users/$fromUserId/friends/$toUserId" to com.example.worldshardestgame_multiplayer.models.Friend(
                userId = toUserId,
                username = toUsername,
                status = "offline",
                addedAt = System.currentTimeMillis()
            ),
            "users/$toUserId/friends/$fromUserId" to com.example.worldshardestgame_multiplayer.models.Friend(
                userId = fromUserId,
                username = fromUsername,
                status = "offline",
                addedAt = System.currentTimeMillis()
            )
        )

        database.updateChildren(updates)
            .addOnSuccessListener { onSuccess() }
            .addOnFailureListener { onError(it.message ?: "Unbekannter Fehler") }
    }

    /**
     * Lehnt eine Freundschaftsanfrage ab
     */
    fun rejectFriendRequest(
        requestId: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        database.child("friendRequests").child(requestId).child("status").setValue("rejected")
            .addOnSuccessListener { onSuccess() }
            .addOnFailureListener { onError(it.message ?: "Unbekannter Fehler") }
    }

    /**
     * Entfernt einen Freund
     */
    fun removeFriend(
        userId: String,
        friendId: String,
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        val updates = hashMapOf<String, Any?>(
            "users/$userId/friends/$friendId" to null,
            "users/$friendId/friends/$userId" to null
        )

        database.updateChildren(updates)
            .addOnSuccessListener { onSuccess() }
            .addOnFailureListener { onError(it.message ?: "Unbekannter Fehler") }
    }

